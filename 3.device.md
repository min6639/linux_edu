디바이스
========

목표

-	기존 시스템을 관찰하여 sysfs를 통해 커널이 장치 설정 정보를 어떤식으로 제공하는지 살펴볼 것이다 몇가지 가자으 기본적인 운영에 대해 이해 할수 있도록 시스템 상의 장에 대한 정보를 얻는것이다.

3.1 장치파일
------------

-	커널이 장치 I/O 인터펭이스를 사용자 프로세스에 파일처럼 제공한다 이런 장치 파일을 장치 노드(device nodes)라고 한다.
-	일반 파일 처럼 사용할 수 있을 뿐 아니라 어떠한 장치의 경우에는 cat 처럼 표준 프로그램으로 접근할 수도 있다.
-	장치파일들은 /dev 디렉터리에 있다 > $ echo blah blah > /dev/null

위 리다이렉트 출력을 /dev/null 장치파일로 전송하고 있다. 커널에서는 dev/null 장치에 작성된 데이터로 무엇을 할지 결정한다. /dev/null 장치 파일의 경우 커널에서 입력을 무시하고 데이터를 버린다

##### ex) windows에서 휴지통에 파일을 버렸다고 생각하면 된다.

---

> [root@was dev]# ls -al </br> total 0 </br> drwxr-xr-x. 18 root root 2940 Jun 20 23:48 . </br> dr-xr-xr-x. 19 root root 275 Apr 21 00:40 .. </br> crw-------. 1 root root 10, 235 Jun 20 23:48 autofs </br> drwxr-xr-x. 2 root root 80 Jun 20 23:48 block </br> drwxr-xr-x. 2 root root 60 Jun 20 23:48 bsg </br> crw-------. 1 root root 10, 234 Jun 20 23:48 btrfs-control </br> srw-rw-rw-. 1 root root 0 Jun 20 23:48 log </br> brw-rw----. 1 root disk 8, 0 Jun 20 23:48 sda </br>

-	위 명령어의 결과값을 보게 되면 접근권한을 볼 수 있다. 각 라인 시작 문자가 b,c,p,s 라면 해당 파일은 장치이다. 이문자는 각 block, character, pipe, socket을 나타낸다.

### 블록장치

-	프로그램은 고정된 양을 가진 블록장치로부터 데이터에 접근한다. sda1은 블록장치의 일종인 디스크 장치다. 디스크는 아주 쉽게 블록 단위의 데이터로 분리된다.

-	블록장칭의 전체 크기는 고정되어 있고, 색인으로 정리하기 쉽기 때문에 프로세스는 커널의 도움으로 장치 안의 어떤 블록이든 임의로 접근할 수 있다.

### 문자 장치

-	문자 장치는 문자 장치에서 문자를 읽을 수 있거나 문자 장치로 문자를 기록 할 수 있다.

-	문자 장치는 크기를 갖고 있지 않다.

-	읽거나 쓸 때 보통 커널이 장치상에서 일고 쓰는 작업을 수행 한다. 컴퓨터에 직접 연결된 프린터는 문자 장치라고 할 수 있다.

-	커널은 테이터를 장치나 프로세스에 전달한 후에 데이터를 백업하고 재검토 하지 않는다.

### 파이프 장치

-	파이프 장치는 네임드 파이프와 비슷하다. 커널 드라이버 대산 I/O 스트림의 다른 쪽에 또 다른 프로세스를 가지고 있다.

> [네임드 파이프]</p> 한 프로세스의 출력을 다른 프로세스의 입력으로 연결해주는 파이프의 하나로, 파이프의 역할을 하는 파일이 존재하여 이 파일을 통해 데이터가 전달됨

### 소켓 장치

-	소켓은 프로세스간의 소통을 우해 자주 사용되는 특수 목적의 인터페이스이다. 종종 /dev 디렉터리 외부에서 볼수 있다.

-	소켓파일들은 유닉스 도메인 소켓에 해당한다.

> Unix domain socket은 TCP의 소켓과 동일한 API 로 데이타를 주고 받을 수 있는 local file 기반의 소켓입니다.</p> TCP socket 과 차이점은 local host 의 process 간의 통신이므로 속도가 매우 빠르고 메모리 소모가 적다는 장점이 있습니다.

3.2 sysfs장치경로
-----------------

-	/dev 안의 장치 이름은 장치에 대해 약간의 정보를 제공 하지만 많은 정보를 주지 않는다.

-	장치들이 발견되는 순서에 따라서 커널이 장치들을 배정한다.

-	리부팅하는 사이 다른 이름을 갖게 될 수도 있다.

-	리눅스 커널은 장치의 실질적인 하드웨어 속성들을 근거로 연결된 장치들을 일정한 관점으로 불 수 있도록 파일과 디렉터리의 시스템을 통해 sysfs 인터페이스를 제공한다.

-	장치들에 대한 기본 경로는 /sys/device다. <span style="color:blue">/dev/sda</span>에 있는 SATA 하드 디스크는 sysfs서 다음과 같은 경로를 갖게 됩니다.

> /sys/devices/pci0000:00/0000:00:01.1/ata1/host0/target0:0:0/0:0:0:0/block

위의 경로는 <span style="color:blue">/dev/sda</span>에 비교해서 아주 길다.

두 경로는 다른 목적을 가지고 있기 떼문에 비교 할 수 없다.<span style="color:blue">/dev</span> 파일은 사용자 프로세스가 장치를 사용할 수 있도록 하기 위해 존재한다. /sys/devices 경로는 정보를 살피고 장치를 관리 하는 데 사용된다.

---

![2-3](./img/sys.PNG)

---

위 경로는 파일과 서브디렉터리들은 사람보다 주로 프로그램이 읽도록 만들졌다.<span style="color:blue">/dev/sda</span>을 예를 살펴보면, 파일과 서브디렉터리들이 무엇을 포함하고 있는지 알 수 있다. 해당 디렉터리에서 <span style="color:red">cat ./dev</span>를 실행하면 8:0이라는 값을 볼 수 있다. 이것은 <span style="color:blue">/dev/sda</span>의 주장치와 부장치 번호이다.

/sys 디렉털에는 몇가지 단축 키가 있다. <span style="color:blue">/sys/block</span>은 시스템에서 사용이 가능한 모든 블록장치들 포함한다. 그러나 이것은 단지 심볼릭 링크다 <span style="color:red">ls -l /sys/block</span>을 실행하면 sysfs의 진짜 경로가 나온다.

---

$ udevadm info --query=all --name=/dev/sda

---

<span style="color:blue">/dev</span>에 있는 어떤 장치의 sysfs 위치를 찾는 것은 어려울 수가 있다. 경로와 기타 속성이 나타나게 하려면 udevadm 명령을 사용한다.

3.3 dd와 장치들
---------------

dd 프로그램은 블록과 문자 장치들과 함께 동작할 때 굉장히 유용하다. 이 프로그램의 기능은 입력 파일을 스트림에서 읽어 오고, 출력 파일을 스트림으로 작성하는 것이다. 인코딩 전환 작업도 가능하다.

---

$ dd if=/dev/zero of=new_file bs=1024 count=1

---

dd 옵션 포멧은 대부분의 다른 유닉스 명령의 옵션 포멧과 다른 면이 있다. 예전의 IBM 작업 제어 언어 스타일을 기초로 하고 있다. 옵션을 표시하는데 대시(-)를 사용하기 보다 옵션의 이름을 표기하고 값을 등호(=) 기호와 함께 해당 옵션에 설정한다. 위의 예제는 <span style="color:blue">/dev/zero</span>(0바이트의 연속 스트림)로 부터 단 하나의 1024-바이트 블록을 new_file로 복사 하고 있다.

#### dd 옵션

1.	if=file </p> 입력파일. 디폴트는 표준 입력이다.
2.	of=file </p> 출력파일. 디포트는 표준 출력이다.
3.	bs=size </p> 블록 사이즈 dd는 한번에 많은 바이트의 데이터를 일고 작성하게 된다 커다란 데이터 덩어리를 줄이려면 각각 512 바이트, 1024바이트를 의미하는 b와 k를 사용할 수 있다. 위의 예제을 bs=1024가 아니라 bs=1k로 읽을 수 있다.
4.	ibs=size, obs=size </p> 입력과 출력 블록 사이즈. 입력과 출력에 대하여 모두 같은 블록 사이즈를 사용할 수 있다면 bs 옵션을 사용 할 수 있다. 그렇지 않은 경우는 각각 입력과 출력에 대하여 ibs와 obs를 사용한다.
5.	count=num </p> 커다라나 파일로 작업하거나 /dev/zero처럼 끝없이 스트림으로 이어지는 데이터를 제공하는 장치와 함께 작업을 하는 경우, 특정 위치에서 dd를 멈추게 한다. 디스크 공간이나 CPU시간 또는 둘 모드를 낭비 할 수 있기 때문이다. 이때, 커다란 파일이나 장치로부터 작은 조각을 복사하는데 skip 매개 변수와 count를 사용한다.
6.	skip=num </p> 입력 파일이나 스트림에서 첫번째 num 블록들을 건너뛰고 이들을 출력으로 복사하지 않는다.

##3.4 장치 이름 요약 때로는 장치의 이름을 찾기가 어려울 수 있다. 다음 장치의 이름을 찾는 몇가지 방법이다.

-	udevadm을 사용하여 udevd에 대해 질의 한다.
-	/sys 디렉터리에서 장치를 찾아 본다.
-	demesg 명령의 출력이나 커널 시스템 로그 파일을 통해 이름을 추측해본다. 이 출력에서 시스템상의 장치들에 관한 설명이 포함 되어 있을 가능성이 있다.
-	시스템에 이미 알려진 디스크 장치의 경우 mount 명령의 출력을 통해 확인해 볼 수 있다.
-	cat /proc/devices를 실행하여 현재 시스템이 드라이버들을 블록이나 문자 장치들을 확인한다. 각 라인은 숫자와 이름으로 구성되어 있다.

###3.4.1 하드 디스크:/dev/sd\*

리눅스 시스템에 연결된 대부분의 하드 디스크들은 /dev/sda, /dev/sdb/ , 등 sd를 접두어로 가진 장치 이름을 갖는 경우가 많다 이러한 장치들은 전체 디스크를 의미 한다. /dev/sda1, /dev/sda2 처럼 디스크상의 파티션들에 대하여 개별적인 장치 파일을 만든다.

이름의 sd 부분은 스카시(Small Computer System Interface,SCSI) 디스크를 나타낸다. SCSI는 원래 디스크 같은 장치들과 그 외 주변 장치들 간의 소통을 위한 하드웨어와 프로토콜 표준으로 개발되었다. 전통적인 SCSI 프로토콜은 융통성이 뛰어나 어디에서난 사용된다.

USB 저장 장치와 통신을 위해 리눅스는 SCSI 프로토콜을 사용한다.

[root@was sda]# lsscsi </p>[0:0:0:0]&nbsp;&nbsp; disk &nbsp;&nbsp;&nbsp; ATA &nbsp;&nbsp; VBOX &nbsp;&nbsp;&nbsp;HARDDISK 1.0 &nbsp;&nbsp;&nbsp;/dev/sda

1.	[0:0:0:0] = 시스템상에 존재하는 장치의 주소다.
2.	disk = 장치의 종류가 어떤 것인지를 나타낸다
3.	/dev/sdaw = 장치 파일을 발견한 장소를 나타내고 있다.

리눅스는 드라이버들이 장치들을 접하게 되는 순서에 따라서 장치에 장치 파일들을 할당 한다.

위의 예제에 의하면 커널은 디스크를 먼저 발견하고, 옵티컬 드라이브 그 다음으로, 플래시 드라이브를 마지막으로 발견한 것이다.

이러한 장치 할당 방식은 전통적으로 하드웨어 변경할 때 문제를 일으켰다. 세 개의 디스크인 /dev/sda, /dev/sdb, /dev/sdc를 가진 시스템을 갖고 있다고 가정했을때, /dev/sdb가 깨져서 머신이 다시 동작 할 수 있도록 디스크를 제거해야 한다면, 이전의 /sdb/sdc는 /dev/sdb로 이동하게 된다. 그리고 더이상 /dev/sdc는 존재하지 않게 된다. /etc/fstab 파일에서 직접 장치 이름을 참조했다면 정상적으로 되돌리기 위해서 파일에 변경을 줘야 한다.

이문제를 해결하기 현재 리눅스 시스템은 지속적으로 디스크 드라이브에 접근 할 수 있도록 보편적 고유 식별자(UUID)를 사용한다.

###3.4.2 CD와 DVD 드라이브: /dev/sr\*

-	리눅스는 대부분의 옵티컬 장치 드라이브를 SCSI 드라이브 /dev/sr0, /dev/sr1 등으로 인식 한다.
-	오래된 인터페이의 경우 PATA 장치로 나타 날수 도 있다.
-	해당 장치는 오직 디스크로부터 읽는 용도라만 사용된다. 옵티컬 장치의 쓰기와 고쳐 쓰는 기능의 경우는 /dev/sg0처럼 "제네릭"SCSI 장치들을 사용한다.

###3.4.3 PATA 하드 디스크: /dev/hd\* + /dev/hda, /dev/hdb, /

dev/hdc와 /dev/hdd는 리눅스 커널의 오래된 버전들에서 흔히 볼 수 있다. 이들은 이터페이스 0과 1의 마스터 장치와 슬레이브 장치를 기초로 고정 할당된다.

###3.4.4 터미널: /dev/tty*, /dev/pts/*, dev/tty + 터미널은

사용자 프로세스와 I/O장치 간의 문자들을 옮기는 장치다.

-	의사 터미널 장치는 실제 터미널의 I/O 기능을 이해아는 모조 터미널이라고 할 수 있다.
-	실제 하드웨어의 일부분과 소통을 하는 것이 아니라 커널이 셸 터미널 윈도우처럼 소프트웨어 일부분에 I/O 인터페이스를 제시한다.

-	흔히 쓰이는 두가지 터미널 장치들은 /dev/tty1(첫 번째 가상 콘솔)과 /dev/pts/0(첫 번째 의사 터미널 장치)이다. /dev/pts 디렉터리는 전용 파일 시스템이다.

#### 디스플레이 모드와 가상콘솔

리눅스는 두개의 디스플레이 모드가 있다. 텍스트모드와 x윈도우 를 갖고 있다. 리눅스 시스템이 전통적으로 텍스트 모드에서 부팅된다고 하더라도 지금은 대부분의 배포판ㄷ르이 커널 매개 변수를 사용 하고 시스템이 부팅하고 있을때 텍스트 모드를 완전히 감추는 임시 그래픽 디스플레이 매커니즘을 사용한다.

리눅스는 ㄷ디스플레이를 다중 방식으로 제공하도록 가상 콘솔을 지원한다. 그래픽 또는 텍스트 모드로 실행한다. 텍스모드에서 키를 조합하여 콘솔 간에 전환 할 수있다 Alt-F1은 /dev/tty1으로 이동하고, Alt-F2 /dev/tty2등으로 이동한다.

가상서버가 그래픽모드로 가동한다면 일반적으로는 CTRL-Alt-Function 키 조합을 사용한다.

-	콘솔 전환에 문제가 발생한다면 chvt 명령으로 시스템이 콘솔을 변경하도록 시도 할 수 있다.

---

$ chvt 1

---

### 3.4.5 직렬포트: /dev/ttyS\*

오래된RS-232 타입이나 그와 유사한 직렬포트들은 특별한 터미널 장치라고 할 수 있다. 직렬포트 장치로는 명령줄에서 많은 것을 할수 없다. 보드속도(baud rate)와 흐름 제어 등 신경 써야 하는 설정들이 너무 많기 때문이다.

### 3.4.6 병렬포트:/dev/lp0와 /dev/lp1

단일 병렬포트 장치(주로 USB) /dev/lp0과 /dev/lp1은 윈도우즈에서 LPT1:과 LPT2:에 해당한다 여러분은 직접 cat 명령을 통해 파일들을 병렬 포트로 전송 할 수 있다. 하지만 프린터에 추가로 폼피드나 리셋을 부여해야 할 것이다. CUPS와 같은 프린터 서버는 프린터와의 상호 작용을 훨씬 더 잘 조절한다.

### 3.4.7 오디오 장치: /dev/snd/*, dev/dsp, /dev/audio 그외 장치들

리눅스는 두 가지 종류의 오디오 장치를 갖고 있다. 하나는 고급 리눅스 아키텍쳐 시스템 인터페이스를 위한 장치고, 다른 하나는 좀더 구식인 오픈 사운드 시스템을 위한 장치다. ALSA 장치는 /dev/snd 디렉터리에 위치한다 그러나 직접 이것들을 사용하기는 어렵다 ALSA를 사욯나는 리눅스 시스템은 만약 OSS 컨러이 현재 로딩 된다면OSS 호환이 간으한 장치를 지원한다.

### 3.4.8 장치 파일 만들기 현재 자체 장치 파일을 생성 하지 않는다. 드문 경우지만 네임드 파이프를 생성해야 할 수도 있다.

mknod 멸령은 장치를 생성한다. 우리는 주장치 번호와 부장치 번호뿐 아니라 장치 이름도 알아야 한다 /dev/sda1을 생성 하려면

---

root@host ~]# mknod /dev/sda1 b 8 2

---

b 8 2는 주장치 번호가 8이고 부장치 번호가 2인 블록 장치를 나타낸다. 문자 장치나 네임드 파이프 장치의 경우 b 대신에 c 또는 p를 사용한다.
mknod명령은 가끔 네임드 파이프를 생성하는 경우에만 융용하다 한때는 시스템복구 시 단일-사용자모드에서 잃어버린 장치들을 생성할 때 유용하게 사용했었다.

유닉스와 리눅스의 오랜된 버전에서 /dev 디렉터리를 유지하는 것은 일종의 도전이었다. 매번 중요한 커널 업그레이드나 드라이버를 추가하면서 커널은 더 많은 종류의 장치들을 지원할 수 있었다. 매번 중요한 커널 업그레이드나 드라이버를 추가하면서 커널은 더많은 종류의 장치들을 지원할 수 있었다. 즉 장치 파일 이름에 새로운 주번호와 부번호가 할당되었고, 이들을 유지하기가 어려웠다. 그래서 각 시스템 장치그룹들을 생성하기 우해 /dev MAKEDEV 프로그램을 보유했다. 시스템을 업그레이드 랫을때, 
MAKEDEV의 업데이트를 찾아서 새로운 장치를 생성하기 위해 실행하곤 했다.


### 3.5 udev 

복잡함은 불안정한 시스템을 야기할 수 있다. 장치파일 관리가 그런 예에 속한다. 우리들은 서로의 공간에서 장치 파일들을 생성할 수 있다 그런데 왜 커널에서 그일을 하려고 하는걸까?
리눅스 커털은 시스템에서 새로운 장치를 탐지하자마자 사용자 공간 프로세스에 알린다 다른 편의 사용자 공간 프로세스는 새로운 장치의 특징을 검토하고 새로운 파일을 만든 후 장치의 초기 설정을 수행한다. 

그것은 이런이다 그러나 안타깜게도 실제로 이런 접근 방식에는 문제가 있다. 장치 파일들은 부팅 과정 초기에 반드시 필요하다. 그래서 udev가 일찍 가동되어야 한다. 장파일들을 생성하기 위해서 udev는 생성되기로 예정되어 있는 어떤 장치에도 의존할 수가 없는 상황이 된다. 또한 시스템의 나머지요소들이 udev가 시작한느 것을 기다리는라 지연되지 않도록 초기 스타트업이 아주 빠르게 실행되어야 한다. 


###3.5.1 devtmpfs

devtmpfs 파일 시스템은 부팅 시에 장치 활ㅇ용 관한 문제에 대응하면서 발전된 시스템이다. 이 파일 시스템은 기존의 devfs가 지원하던 것과 유사하지만 단순화 된것이다 커널은 필요에 따라서 장치 파일들을 생성하고 새롱누 장치를 사용할 수 있다는 것을 udevd에 통지한다. 이 신호를 받으면 udevd는 장치 파일을 생성하지 않지만, 장치 초기 설정을 수행하고 프로세스에 통지한다. 
게다가 장치를 식별하도록 /dev에 많은 심볼릭 링크들을 생성한다. /dev/disk/by_id 디렉터리에서 이런  예들을 발견할 수 있는 것이다. 여기서 각각의 연결된 디스크는 하나 혹은 그 이상의 항목들을 가지고 있다.

udevd는 인터페이스 타입, 제조사와 모델 정보, 시리얼 번호, 그리고 파티션으로 링크의 이름을 명명한다. 그렇다면 udev는 어떤 심볼릭 링크가 생성될 것인지 그리고 얻허게 이들을 생성할 것인지 어떻게 알 수 있을까? 다음 절은 udev가 어떤 방식으로 작업에 수행 하는지 설명 하고 잇다. 그러나 이책의 진도를 이어나갈 때 이부분에 대해 꼭 알 필요는 없다 만약 리눅스장치를 이번에 처음으로 경험하는 것이라면 다음 장으로 옮겨서 디스크 사용법에 대해서 학습하도록 권장한다. 


### 3.5.2 udevd 운영과 설정

udevd 데몬은 다으모가 같이 동작한다.

 1. 커널은 udev로 내부 네트워크 링크를 통해서 uevent라고 불리는 알림 이벤트를 전송한다. 
 2. udevd는 uevent 안의 모든 속성들을 로딩한다. 
 3. udevd는 그 규칙들을 분석하고 조치를 취하거나 그 규칙들을 기반으로 더 많은 속성들을 설정한다. 


### 3.6 SCSI와 리눅스 커널에 대한 상세 분석

전통적인 SCSI 하드웨어 구성은 버스를 통해 여러 장치들이 연결된 호스트 어댑터다. 호스트 어댑터는 컴퓨터에 연결된다. 호스트 어댑터와 장치들은 가각 SCSI ID를 갖고 있다. 그리고 SCSI 버전에 따라서 버스당 ID가 8개일 수도 있고 16개일 수도 있다. SCSI타킷이라는 용어가 장치와 SCSI ID를 나타내는 데 사용되는 것을 볼 수 있을 것이다. 

호스트 어댑터는 피어-투피어 관계로 SCSI 명령 집합을 통해 장치와 소통하낟 장치들은 호스트 어댑터로 반응을 전송한다. 컴퓨터는 직접 장치 사슬에 연결되지 않기 때문에 디스크와 다른 장치들과 소통을 하려면 호스트 어댑터를 통해야 한다. 일반적으로 컴퓨터는 장치로 SCSI 명령을 전달하기 우해서 호스트 어댑터로 전송한다. 그리고 장치는 호스트 어댑터로 반응들을 다시 전달한다.

Serial Attached SCSI와 같은 SCSI의새로운 버전들은 아주 뛰어난 기능을 제공한다. 대부분의 머신에서 SCSI 장치들을 찾을 수 없을 것이다. 대신 SCSI명령을 사용하는 USB저장 장치를 훨씬 더 자주 보게 될 것이다. 게다가 ATAPI를 지원하는 장치들은 SCSI 집합의 한 버전을 사용한다. 

SATA 디스크 역시 libata의 번역 계층을 통해 SCSI 장치로 시스템상에 나타난다 일부 SATA 컨트롤러는 하드에워에서 이런 번역을 실행한다. 

상위와 하위 레이어는 여러 가지 종류의 드라이버들을 포함하고 있다. 하지만 시스템상에 어떤 장치 파일이 주어지든지 커널은 하나의 사우이 레이어 드라이버와 하나의 하위 레이어 드라이버와 하나의 하위 레이어 드라이버를 사용한다는 점이 중요하다. /dev/sda의 디스크의 경우도 커널이 sd 상위 레이어 드랑비와 ATA브리지 하위 레이어 드라이버를 사용하고 있다.

한 개의 하드웨어 장치를 위하여 한 개 이상의 상위 레이어 드라이버를 사용해야 할 때도 있다 SCSI호스트 어댑터나 하드웨어 RAID 컨트롤러에 연결된 디스크처럼 실제 하드웨어 SCSI 장치들의 경우, 하위 레이어 드라이버는 직접 그 아랭의 하드웨어와 소통한다. 그러나 SCSI 서브시스템에 연결된 대부분의 하드웨어의 경우는 다르게 접근한다. 

### 3.6.1 USB저장 장치와 SCSI

SCSI드라이버보다 더 많은 것을 필요로 한다. /dev/sdf로 표현되는 USB플래시 드라이버는 SCSI명령을 이해한다. 하지만 드라이버와 실제로 소통을 하려면 커널이 USB 시스템을 통해 소통하는 방법을 알아야 한다.

대략적으로 USB는 SCSI와 매우 유사하다. USB는 장치 클래스, 버스와 호스트 컨트롤러를 갖고 있다. 그래서 리눅스 커널이 SCSI 서브시스템과 아주 유사한 3단 레이어 USB서브시스템을 포함하는 것은 놀라운 일도 아니다. -상위에 장치 클래스 드라이버, 중간에 버스 관리 코어, 하위에 호스트 컨트롤러 드라이버를 갖추고 있는 시스템이다. SCSI 서브시스템은 그 요소 간에 USB 메시지를 전달한다. 게다가 lsscsi와 유사한 lsusb 명령도 있다.





















