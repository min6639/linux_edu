디바이스
========

목표

-	기존 시스템을 관찰하여 sysfs를 통해 커널이 장치 설정 정보를 어떤식으로 제공하는지 살펴볼 것이다 몇가지 가자으 기본적인 운영에 대해 이해 할수 있도록 시스템 상의 장에 대한 정보를 얻는것이다.

3.1 장치파일
------------

-	커널이 장치 I/O 인터펭이스를 사용자 프로세스에 파일처럼 제공한다 이런 장치 파일을 장치 노드(device nodes)라고 한다.
-	일반 파일 처럼 사용할 수 있을 뿐 아니라 어떠한 장치의 경우에는 cat 처럼 표준 프로그램으로 접근할 수도 있다.
-	장치파일들은 /dev 디렉터리에 있다 > $ echo blah blah > /dev/null

위 리다이렉트 출력을 /dev/null 장치파일로 전송하고 있다. 커널에서는 dev/null 장치에 작성된 데이터로 무엇을 할지 결정한다. /dev/null 장치 파일의 경우 커널에서 입력을 무시하고 데이터를 버린다

##### ex) windows에서 휴지통에 파일을 버렸다고 생각하면 된다.

---

> [root@was dev]# ls -al </br> total 0 </br> drwxr-xr-x. 18 root root 2940 Jun 20 23:48 . </br> dr-xr-xr-x. 19 root root 275 Apr 21 00:40 .. </br> crw-------. 1 root root 10, 235 Jun 20 23:48 autofs </br> drwxr-xr-x. 2 root root 80 Jun 20 23:48 block </br> drwxr-xr-x. 2 root root 60 Jun 20 23:48 bsg </br> crw-------. 1 root root 10, 234 Jun 20 23:48 btrfs-control </br> srw-rw-rw-. 1 root root 0 Jun 20 23:48 log </br> brw-rw----. 1 root disk 8, 0 Jun 20 23:48 sda </br>

-	위 명령어의 결과값을 보게 되면 접근권한을 볼 수 있다. 각 라인 시작 문자가 b,c,p,s 라면 해당 파일은 장치이다. 이문자는 각 block, character, pipe, socket을 나타낸다.

### 블록장치

-	프로그램은 고정된 양을 가진 블록장치로부터 데이터에 접근한다. sda1은 블록장치의 일종인 디스크 장치다. 디스크는 아주 쉽게 블록 단위의 데이터로 분리된다.

-	블록장칭의 전체 크기는 고정되어 있고, 색인으로 정리하기 쉽기 때문에 프로세스는 커널의 도움으로 장치 안의 어떤 블록이든 임의로 접근할 수 있다.

### 문자 장치

-	문자 장치는 문자 장치에서 문자를 읽을 수 있거나 문자 장치로 문자를 기록 할 수 있다.

-	문자 장치는 크기를 갖고 있지 않다.

-	읽거나 쓸 때 보통 커널이 장치상에서 일고 쓰는 작업을 수행 한다. 컴퓨터에 직접 연결된 프린터는 문자 장치라고 할 수 있다.

-	커널은 테이터를 장치나 프로세스에 전달한 후에 데이터를 백업하고 재검토 하지 않는다.

### 파이프 장치

-	파이프 장치는 네임드 파이프와 비슷하다. 커널 드라이버 대산 I/O 스트림의 다른 쪽에 또 다른 프로세스를 가지고 있다.

> [네임드 파이프]</p> 한 프로세스의 출력을 다른 프로세스의 입력으로 연결해주는 파이프의 하나로, 파이프의 역할을 하는 파일이 존재하여 이 파일을 통해 데이터가 전달됨

### 소켓 장치

-	소켓은 프로세스간의 소통을 우해 자주 사용되는 특수 목적의 인터페이스이다. 종종 /dev 디렉터리 외부에서 볼수 있다.

-	소켓파일들은 유닉스 도메인 소켓에 해당한다.

> Unix domain socket은 TCP의 소켓과 동일한 API 로 데이타를 주고 받을 수 있는 local file 기반의 소켓입니다.</p> TCP socket 과 차이점은 local host 의 process 간의 통신이므로 속도가 매우 빠르고 메모리 소모가 적다는 장점이 있습니다.

3.2 sysfs장치경로
-----------------

-	/dev 안의 장치 이름은 장치에 대해 약간의 정보를 제공 하지만 많은 정보를 주지 않는다.

-	장치들이 발견되는 순서에 따라서 커널이 장치들을 배정한다.

-	리부팅하는 사이 다른 이름을 갖게 될 수도 있다.

-	리눅스 커널은 장치의 실질적인 하드웨어 속성들을 근거로 연결된 장치들을 일정한 관점으로 불 수 있도록 파일과 디렉터리의 시스템을 통해 sysfs 인터페이스를 제공한다.

-	장치들에 대한 기본 경로는 /sys/device다. <span style="color:blue">/dev/sda</span>에 있는 SATA 하드 디스크는 sysfs서 다음과 같은 경로를 갖게 됩니다.

> /sys/devices/pci0000:00/0000:00:01.1/ata1/host0/target0:0:0/0:0:0:0/block

위의 경로는 <span style="color:blue">/dev/sda</span>에 비교해서 아주 길다.

두 경로는 다른 목적을 가지고 있기 떼문에 비교 할 수 없다.<span style="color:blue">/dev</span> 파일은 사용자 프로세스가 장치를 사용할 수 있도록 하기 위해 존재한다. /sys/devices 경로는 정보를 살피고 장치를 관리 하는 데 사용된다.

---

![2-3](./img/sys.PNG)

---

위 경로는 파일과 서브디렉터리들은 사람보다 주로 프로그램이 읽도록 만들졌다.<span style="color:blue">/dev/sda</span>을 예를 살펴보면, 파일과 서브디렉터리들이 무엇을 포함하고 있는지 알 수 있다. 해당 디렉터리에서 <span style="color:red">cat ./dev</span>를 실행하면 8:0이라는 값을 볼 수 있다. 이것은 <span style="color:blue">/dev/sda</span>의 주장치와 부장치 번호이다.

/sys 디렉털에는 몇가지 단축 키가 있다. <span style="color:blue">/sys/block</span>은 시스템에서 사용이 가능한 모든 블록장치들 포함한다. 그러나 이것은 단지 심볼릭 링크다 <span style="color:red">ls -l /sys/block</span>을 실행하면 sysfs의 진짜 경로가 나온다.

---

$ udevadm info --query=all --name=/dev/sda

---

<span style="color:blue">/dev</span>에 있는 어떤 장치의 sysfs 위치를 찾는 것은 어려울 수가 있다. 경로와 기타 속성이 나타나게 하려면 udevadm 명령을 사용한다.

3.3 dd와 장치들
---------------

dd 프로그램은 블록과 문자 장치들과 함께 동작할 때 굉장히 유용하다. 이 프로그램의 기능은 입력 파일을 스트림에서 읽어 오고, 출력 파일을 스트림으로 작성하는 것이다. 인코딩 전환 작업도 가능하다.

---

$ dd if=/dev/zero of=new_file bs=1024 count=1

---

dd 옵션 포멧은 대부분의 다른 유닉스 명령의 옵션 포멧과 다른 면이 있다. 예전의 IBM 작업 제어 언어 스타일을 기초로 하고 있다. 옵션을 표시하는데 대시(-)를 사용하기 보다 옵션의 이름을 표기하고 값을 등호(=) 기호와 함께 해당 옵션에 설정한다. 위의 예제는 <span style="color:blue">/dev/zero</span>(0바이트의 연속 스트림)로 부터 단 하나의 1024-바이트 블록을 new_file로 복사 하고 있다.

#### dd 옵션

1.	if=file </p> 입력파일. 디폴트는 표준 입력이다.
2.	of=file </p> 출력파일. 디포트는 표준 출력이다.
3.	bs=size </p> 블록 사이즈 dd는 한번에 많은 바이트의 데이터를 일고 작성하게 된다 커다란 데이터 덩어리를 줄이려면 각각 512 바이트, 1024바이트를 의미하는 b와 k를 사용할 수 있다. 위의 예제을 bs=1024가 아니라 bs=1k로 읽을 수 있다.
4.	ibs=size, obs=size </p> 입력과 출력 블록 사이즈. 입력과 출력에 대하여 모두 같은 블록 사이즈를 사용할 수 있다면 bs 옵션을 사용 할 수 있다. 그렇지 않은 경우는 각각 입력과 출력에 대하여 ibs와 obs를 사용한다.
5.	count=num </p> 커다라나 파일로 작업하거나 /dev/zero처럼 끝없이 스트림으로 이어지는 데이터를 제공하는 장치와 함께 작업을 하는 경우, 특정 위치에서 dd를 멈추게 한다. 디스크 공간이나 CPU시간 또는 둘 모드를 낭비 할 수 있기 때문이다. 이때, 커다란 파일이나 장치로부터 작은 조각을 복사하는데 skip 매개 변수와 count를 사용한다.
6.	skip=num </p> 입력 파일이나 스트림에서 첫번째 num 블록들을 건너뛰고 이들을 출력으로 복사하지 않는다.

##3.4 장치 이름 요약 때로는 장치의 이름을 찾기가 어려울 수 있다. 다음 장치의 이름을 찾는 몇가지 방법이다.

-	udevadm을 사용하여 udevd에 대해 질의 한다.
-	/sys 디렉터리에서 장치를 찾아 본다.
-	demesg 명령의 출력이나 커널 시스템 로그 파일을 통해 이름을 추측해본다. 이 출력에서 시스템상의 장치들에 관한 설명이 포함 되어 있을 가능성이 있다.
-	시스템에 이미 알려진 디스크 장치의 경우 mount 명령의 출력을 통해 확인해 볼 수 있다.
-	cat /proc/devices를 실행하여 현재 시스템이 드라이버들을 블록이나 문자 장치들을 확인한다. 각 라인은 숫자와 이름으로 구성되어 있다.

###3.4.1 하드 디스크:/dev/sd\*

리눅스 시스템에 연결된 대부분의 하드 디스크들은 /dev/sda, /dev/sdb/ , 등 sd를 접두어로 가진 장치 이름을 갖는 경우가 많다 이러한 장치들은 전체 디스크를 의미 한다. /dev/sda1, /dev/sda2 처럼 디스크상의 파티션들에 대하여 개별적인 장치 파일을 만든다.

이름의 sd 부분은 스카시(Small Computer System Interface,SCSI) 디스크를 나타낸다. SCSI는 원래 디스크 같은 장치들과 그 외 주변 장치들 간의 소통을 위한 하드웨어와 프로토콜 표준으로 개발되었다. 전통적인 SCSI 프로토콜은 융통성이 뛰어나 어디에서난 사용된다.

USB 저장 장치와 통신을 위해 리눅스는 SCSI 프로토콜을 사용한다.

[root@was sda]# lsscsi </p>[0:0:0:0]&nbsp;&nbsp; disk &nbsp;&nbsp;&nbsp; ATA &nbsp;&nbsp; VBOX &nbsp;&nbsp;&nbsp;HARDDISK 1.0 &nbsp;&nbsp;&nbsp;/dev/sda

1.	[0:0:0:0] = 시스템상에 존재하는 장치의 주소다.
2.	disk = 장치의 종류가 어떤 것인지를 나타낸다
3.	/dev/sdaw = 장치 파일을 발견한 장소를 나타내고 있다.

리눅스는 드라이버들이 장치들을 접하게 되는 순서에 따라서 장치에 장치 파일들을 할당 한다.

위의 예제에 의하면 커널은 디스크를 먼저 발견하고, 옵티컬 드라이브 그 다음으로, 플래시 드라이브를 마지막으로 발견한 것이다.

이러한 장치 할당 방식은 전통적으로 하드웨어 변경할 때 문제를 일으켰다. 세 개의 디스크인 /dev/sda, /dev/sdb, /dev/sdc를 가진 시스템을 갖고 있다고 가정했을때, /dev/sdb가 깨져서 머신이 다시 동작 할 수 있도록 디스크를 제거해야 한다면, 이전의 /sdb/sdc는 /dev/sdb로 이동하게 된다. 그리고 더이상 /dev/sdc는 존재하지 않게 된다. /etc/fstab 파일에서 직접 장치 이름을 참조했다면 정상적으로 되돌리기 위해서 파일에 변경을 줘야 한다.

이문제를 해결하기 현재 리눅스 시스템은 지속적으로 디스크 드라이브에 접근 할 수 있도록 보편적 고유 식별자(UUID)를 사용한다.

###3.4.2 CD와 DVD 드라이브: /dev/sr\*

-	리눅스는 대부분의 옵티컬 장치 드라이브를 SCSI 드라이브 /dev/sr0, /dev/sr1 등으로 인식 한다.
-	오래된 인터페이의 경우 PATA 장치로 나타 날수 도 있다.
-	해당 장치는 오직 디스크로부터 읽는 용도라만 사용된다. 옵티컬 장치의 쓰기와 고쳐 쓰는 기능의 경우는 /dev/sg0처럼 "제네릭"SCSI 장치들을 사용한다.

###3.4.3 PATA 하드 디스크: /dev/hd\* + /dev/hda, /dev/hdb, /

dev/hdc와 /dev/hdd는 리눅스 커널의 오래된 버전들에서 흔히 볼 수 있다. 이들은 이터페이스 0과 1의 마스터 장치와 슬레이브 장치를 기초로 고정 할당된다.

###3.4.4 터미널: /dev/tty*, /dev/pts/*, dev/tty + 터미널은

사용자 프로세스와 I/O장치 간의 문자들을 옮기는 장치다.

-	의사 터미널 장치는 실제 터미널의 I/O 기능을 이해아는 모조 터미널이라고 할 수 있다.
-	실제 하드웨어의 일부분과 소통을 하는 것이 아니라 커널이 셸 터미널 윈도우처럼 소프트웨어 일부분에 I/O 인터페이스를 제시한다.

-	흔히 쓰이는 두가지 터미널 장치들은 /dev/tty1(첫 번째 가상 콘솔)과 /dev/pts/0(첫 번째 의사 터미널 장치)이다. /dev/pts 디렉터리는 전용 파일 시스템이다.

#### 디스플레이 모드와 가상콘솔

리눅스는 두개의 디스플레이 모드가 있다. 텍스트모드와 x윈도우 를 갖고 있다. 리눅스 시스템이 전통적으로 텍스트 모드에서 부팅된다고 하더라도 지금은 대부분의 배포판ㄷ르이 커널 매개 변수를 사용 하고 시스템이 부팅하고 있을때 텍스트 모드를 완전히 감추는 임시 그래픽 디스플레이 매커니즘을 사용한다.

리눅스는 ㄷ디스플레이를 다중 방식으로 제공하도록 가상 콘솔을 지원한다. 그래픽 또는 텍스트 모드로 실행한다. 텍스모드에서 키를 조합하여 콘솔 간에 전환 할 수있다 Alt-F1은 /dev/tty1으로 이동하고, Alt-F2 /dev/tty2등으로 이동한다.

가상서버가 그래픽모드로 가동한다면 일반적으로는 CTRL-Alt-Function 키 조합을 사용한다.

-	콘솔 전환에 문제가 발생한다면 chvt 명령으로 시스템이 콘솔을 변경하도록 시도 할 수 있다.

---

$ chvt 1

---

###3.4.5 직렬포트: /dev/ttyS\*

오래된RS-232 타입이나 그와 유사한 직렬포트들은 특별한 터미널 장치라고 할 수 있다. 직렬포트 장치로는 명령줄에서 많은 것을 할수 없다. 보드속도(baud rate)와 흐름 제어 등 신경 써야 하는 설정들이 너무 많기 때문이다.

###3.4.6 병렬포트:/dev/lp0와 /dev/lp1

단일 병렬포트 장치(주로 USB) /dev/lp0과 /dev/lp1은 윈도우즈에서 LPT1:과 LPT2:에 해당한다 여러분은 직접 cat 명령을 통해 파일들을 병렬 포트로 전송 할 수 있다. 하지만 프린터에 추가로 폼피드나 리셋을 부여해야 할 것이다. CUPS와 같은 프린터 서버는 프린터와의 상호 작용을 훨씬 더 잘 조절한다.

###3.4.7 오디오 장치: /dev/snd/*, dev/dsp, /dev/audio 그외 장치들

리눅스는 두 가지 종류의 오디오 장치를 갖고 있다. 하나는 고급 리눅스 아키텍쳐 시스템 인터페이스를 위한 장치고, 다른 하나는 좀더 구식인 오픈 사운드 시스템을 위한 장치다. ALSA 장치는 /dev/snd 디렉터리에 위치한다 그러나 직접 이것들을 사용하기는 어렵다 ALSA를 사욯나는 리눅스 시스템은 만약 OSS 컨러이 현재 로딩 된다면OSS 호환이 간으한 장치를 지원한다.

###3.4.8 장치 파일 만들기 현재 자체 장치 파일을 생성 하지 않는다. 드문 경우지만 네임드 파이프를 생성해야 할 수도 있다.

mknod 멸령은 장치를 생성한다. 우리는 주장치 번호와 부장치 번호뿐 아니라 장치 이름도 알아야 한다 /dev/sda1을 생성 하려면

---

root@host ~]# mknod /dev/sda1 b 8 2

---

b 8 2는 주장치 번호가 8이고 부장치 번호가 2인 블록 장치를 나타낸다. 문자 장치나 네임드 파이프 장치의 경우 b 대신에 c 또는 p를 사용한다.
